# 🎨 드로우! Draw!

드로우! Draw!는 사용자가 자유롭게 그림 혹은 글자를 그리면 그것이 무엇인지 예측한 후 이를 화면에 떠다니던 색깔 공을 이용해 다시 그려주는 유아용 그림 놀이 및 교육 웹 애플리케이션입니다.

<br />

# 💡 프로젝트 동기

이전부터 캔버스를 이용하여 그래픽을 그리는 작업에 관심이 있어서 이를 이용한 애플리케이션을 만들어보고 싶었습니다. 그러던 중 WebGL을 이용한 다양한 웹 사이트를 접하게 되었고, 이를 응용하면 재밌는 결과물이 만들어질 거 같아 도전해보게 되었습니다.

더불어 프론트엔드 프레임워크를 사용하지 않고 하나의 프로젝트를 완성해보고 싶었습니다. 리액트를 이용하여 어렵지 않게 구현할 수 있었던 기능들을 하나하나 직접 구현해보면서 리액트와 다른 자바스크립트 기본에 대해 더 깊이 공부하고자 했습니다.

<br />

# 📆 프로젝트 기간

- Week 1 (2022/06/27 ~ 2022/07/03)

  - 아이디어 선정 및 구체화
  - 기술 스택 검증 및 정리
  - mock up 및 칸반 작성

- Week 2 (2022/07/04 ~ 2022/07/17)
  - Webpack 설정
  - 개발 진행
  - 리팩토링 및 버그 수정
  - Netlify 배포

<br />

# 📚 기술 스택

- Javascript
- Three.js
- GSAP
- opentype.js
- Translate
- MobX
- webpack 5
- SCSS
- HTML
- EsLint
- Prettier
- Git
- Netlify

<br />

# 🛹 배포 링크 및 세팅 방법

### 배포 링크

http://draw-draw.site

### 프로젝트 세팅 방법

프로젝트 디렉토리 최상단에 .env 파일을 생성해 주세요. Google API 사용을 위한 API_KEY가 필요합니다.

```
$ git clone https://github.com/ConnectWithHands/ConnectWithHands-client.git
$ npm install
$ npm start
```

<br />

# ✨ 주요 기능

본 애플리케이션은 MobX를 이용하여 observable data의 변화에 따라 동적으로 HTML DOM을 업데이트하는 방식으로 구현된 Single Page Application(SPA)입니다.

<br />

### 드로잉 페이지

https://user-images.githubusercontent.com/89576038/181205480-a612a14f-9d99-4ce4-b083-99eaca9c9b38.mp4

- 맨 처음 웹 페이지에 들어가면 드로잉 페이지를 볼 수 있습니다. 드로잉 페이지에서 사용자는 회전하고 있는 색깔 공들을 볼 수 있습니다.
- 사용자가 마우스를 움직이면 마우스 움직임에 맞춰 색깔 공이 움직입니다.
- 마우스 휠을 이용해 줌인/줌아웃 할 수 있습니다.

<br />

### 그림 그리기

https://user-images.githubusercontent.com/89576038/181112271-1654af4e-c790-4fe1-b82f-985840596047.mp4

- 사용자는 마우스를 움직여 그림을 그릴 수 있습니다.
- 사용자가 그림을 그리던 중 일정 시간 이상 마우스 움직임을 멈추게 되면 그림 목록 예측 페이지로 화면이 바뀝니다.

<br />

### 그림 목록 예측 페이지

https://user-images.githubusercontent.com/89576038/181116495-3698f8d9-991a-4218-9d07-857814778039.mp4

- 사용자가 그린 그림이 무엇인지 예측한 목록과 함께 첫 번째 예측 그림이 색깔 공으로 뒤덮인 형태로 나타납니다.
- 예측 그림 목록의 각 아이템을 클릭하면 이전의 그림은 사라지고 선택된 그림이 색깔 공으로 뒤덮인 형태로 나타납니다.
- 클릭할 때마다 배경색 및 색깔 공의 포인트 색이 달라집니다.

https://user-images.githubusercontent.com/89576038/181199233-b2e62f3b-2bd7-4f9c-a184-b018959df657.mp4

- 색깔 공으로 뒤덮인 결과물 위에 바로 그림을 그릴 수 있습니다.

<br />

### 글자 그리기

https://user-images.githubusercontent.com/89576038/181386546-9e8355ef-37d6-4e84-864c-21bc2c2ef88e.mp4

- 사용자는 언제라도 모드 변경 아이콘을 클릭하여 지체 없이 모드를 변경할 수 있습니다.
- 사용자는 마우스를 움직여 글자를 그릴 수 있습니다.
- 사용자가 글자를 그리던 중 일정 시간 이상 마우스 움직임을 멈추게 되면 글자 예측 페이지로 화면이 바뀝니다.

<br />

### 글자 예측 페이지

https://user-images.githubusercontent.com/89576038/181116886-7b156eee-a0b8-4f15-9c37-a4a8d0031811.mp4

- 사용자가 그린 글자가 무엇인지 예측한 결과가 색깔 공으로 뒤덮인 형태로 나타납니다.

https://user-images.githubusercontent.com/89576038/181199165-25798edd-9364-4c9c-828e-4fe0c1b26ed3.mp4

- 색깔 공으로 뒤덮인 결과물 위에 바로 글자를 그릴 수 있습니다.

<br />

### 음성 듣기

- 사용자는 예측 페이지에서만 나타나는 음성 듣기 아이콘을 클릭하여 예측 그림 목록에서 선택된 그림 이름과 예측 글자의 발음을 들을 수 있습니다.

<br />

# 🔎 작업 로그 및 챌린지

### 1. 색깔 공 배치 및 애니메이션 적용하기

캔버스에 그릴 예측 그림이 svg Img이기 때문에 그림 위에 색깔 공을 배치하기 위해 svg path를 이용하고자 했습니다. 이에 따라 그림 모드뿐 아니라 글자 모드에서도 svg path를 구하고자 했습니다. 그림 모드에서는 Autodraw API를 이용해 만든 svg url을 이용하여 svg img를 만든 후 이로부터 path를 구했습니다. 글자 모드에서는 Vision API를 이용해 인식한 글자를 openType.js를 이용해 svg text로 만든 후 이로부터 path를 구했습니다.

위 과정을 통해 얻은 svg path를 3D 공간 상의 색깔 공으로 표현하기 위해 svg path를 기반으로 vertices를 생성했습니다. 이는 최종적으로 그림 혹은 글자를 뒤덮을 색깔 공들의 위치, 색깔, 크기 정보를 담고 있는 THREE.Vector3 객체를 생성하여 만들었습니다. 색깔 공을 배치하기 위해서는 타임라인 기반 애니메이션을 적용하기 위해 GSAP을 이용했습니다. 애니메이션이 시작되는 위치 및 색깔 정보를 랜덤하게 할당하여 새로운 예측 그림 혹은 글자를 볼 때마다 랜덤한 효과의 애니메이션이 적용되도록 구현했습니다. 해당 vertices를 바탕으로 points를 만들어 화면에 최종적으로 보여주었습니다.

<br />

### 2. 속도 및 성능 개선

Autodraw API를 이용해 만든 svg url 중 유효하지 않은 url을 예측 그림 목록에서 제외시키기 위해 API로부터 만든 스무 개의 url 주소에 매번 요청을 보내야 했습니다. 그러나 다수의 url 주소로 요청을 연속적으로 보내는 것은 그림을 그린 후 예측 페이지를 보여줄 때마다 시간이 딜레이되는 문제를 야기했습니다. 검색을 해보니 axios.all을 이용해 여러 개의 요청을 병렬적으로 보낼 수 있었지만 이미 deprecated 되었기 때문에 promise.all을 이용해야 했습니다. 그러나 promise.all 또한 다수의 요청 중 하나라도 실패하게 되면 전체를 실패로 간주하기 때문에 모든 url을 검증하기 위해 사용하기에는 적절하지 않았습니다. 결과적으로 promise.allSettled를 이용하여 axios 요청을 병렬적으로 보냄으로써 해당 문제를 개선할 수 있었습니다. 추가적으로 속도를 개선하기 위해 axios.get 대신에 response data로 빈 값을 받는 axios.head를 이용했습니다.

한편, 모드 변경 시 scene.remove(object)를 이용하여 이전 화면에 있던 오브젝트를 삭제하고 현재 페이지에 맞게 화면을 업데이트 하도록 코드를 작성했습니다. 그러나 실제로 테스트해보면 이전 화면에 있던 오브젝트가 제대로 지워지지 않아 다시 이전 화면으로 돌아가 그림을 그릴 시 3D 변환 과정에서 잠깐 이전 오브젝트가 보인 후에 새로운 오브젝트가 보이는 문제가 있었습니다. 이 또한 한번 만들어진 오브젝트가 제대로 삭제되지 않고 계속 쌓이고 있음을 뜻하기 때문에 속도 및 성능에 영향을 미치는 요인이라고 생각했습니다. 따라서, 오브젝트를 완전히 삭제하기 위해 재귀 함수를 이용한 오브젝트 제거 함수를 추가했습니다. 일련의 과정들을 통해 관련 버그가 해결되고 웹 사이트 속도가 향상된 것을 체감할 수 있었습니다.

<br />

### 3. Javascript 환경에서 MobX를 이용하여 HTML DOM 업데이트

드로우! Draw!에서는 상태 변화에 따라 Three.js의 특정 오브젝트를 렌더링하고 UI를 업데이트 하기 위해 MobX라는 전역 상태관리 라이브러리를 사용했습니다. MobX는 flux pattern을 바탕으로 특정 상태 값을 관찰하고 있다가 해당 값이 바뀔 때마다 특정 작업을 바로 실행시킵니다. 이는 데이터를 정규화할 필요 없이 상태와 파생 간의 관계를 자동으로 추적함으로써 참조 무결성을 보장해주며, 간편하고 효율적으로 상태를 관리할 수 있도록 합니다.

먼저, 애플리케이션에 필요한 상태를 MobX의 observable로 정의한 후 상태가 변할 때마다 특정 작업이 실행되도록 했습니다. 예를 들어, 그림 모드에서 글자 모드로 변경 시 state를 수정하는 action이 실행되어 state가 변경되면 해당 state의 변화가 감지됨에 따라 미리 작성해둔 특정 함수가 실행됩니다. 여기서 특정 함수로 Three.js의 오브젝트를 렌더링하는 함수 그리고 UI를 업데이트하거나 초기화하는 함수를 정의하여 사용하였습니다.

<br />

### 4. 그림 및 글자 그리기 로직에 Debounce 적용하기

사용자가 그림 혹은 글자를 그리기를 완전히 끝낸 후 예측 결과를 받아오기 위해 매번 버튼을 누르도록 하는 것이 UI/UX 관점에서 좋지 못하다는 생각이 들었습니다. 사용자가 그리기 작업에만 집중할 수 있도록 화면을 최대한 깔끔하게 구성하고자 했고, 그 예측 결과 또한 추가 작업 없이 곧바로 볼 수 있도록 하고자 했습니다.

이를 위해 마우스를 뗀 다음 일정 시간이 지나야만 사용자가 그린 그림이 사라짐과 동시에 API 요청을 보내도록 Debounce를 적용했습니다. 마우스를 뗀 후 일정 시간이 경과하기 전에 다시 마우스를 이용해 그림을 이어 그리면 전체 그림을 이루고 있는 좌표값들만 계속 업데이트되도록 했습니다.

다만, Debounce 안에서 API 요청을 보내다 보니 이전 API 요청이 진행 중인 와중에 사용자가 그림을 이어서 그린 경우 Debounce에 지정한 시간이 다시 경과했다면 API 요청이 중복으로 보내지게 되어 첫 번째 요청에 의해 예측 페이지가 보인 후 곧바로 다시 두 번째 예측 페이지가 보이는 문제가 있었습니다. 이를 해결하기 위해 API 요청이 진행 중인 경우에는 사용자가 그림을 그릴 수 없도록 코드를 수정했습니다.

<br />

# 🍀 프로젝트 소감

본 프로젝트에서는 상태가 변경됨에 따라 특정 3D 오브젝트를 렌더링하고 UI를 업데이트 하기 위해 전역 상태관리 라이브러리인 MobX를 사용했습니다. 이를 적용하기에 앞서 MVC pattern과 Flux pattern의 장단점을 분석하고, MobX의 핵심 원리를 공부하는 시간을 가졌습니다. 리액트를 사용하지 않고 특정 상태 변화에 맞춰 UI가 즉각적으로 변경되는 SPA를 구현해보면서 많은 버그와 맞닥뜨리며 리액트에서 기본적으로 제공해주는 기능이 얼마나 편리한 것인지를 새삼 체감할 수 있었습니다. 또한, 평소 사용했던 리액트와 같은 프론트엔드 프레임워크가 어떤 원리로 SPA를 지원해주는지를 배우고 이해할 수 있었습니다.

한편, 사용자가 2D Canvas에 그린 그림을 WebGL Canvas에 Three.js와 GSAP을 이용하여 다시 그려줌으로써 사용자 인터렉션에 따라 역동적으로 UI를 구성하는 방법을 공부할 수 있었습니다. Three.js 관련 개념을 익히는 게 쉽지는 않았지만, 전부터 배워보고 싶었던 캔버스를 이용한 작업을 프로젝트에 직접 적용해볼 수 있었기에 어렵고 힘든 한편 재밌기도 했고 값진 시간이었습니다.

처음 개발을 시작할 당시 HTML, Javascript 등과 같은 기본 스택을 제외하고는 전부 실제로 개발 과정에는 처음 도입해보는 것들이라 걱정이 많았습니다. 과연 기술 검증을 제대로 한 것인지, 그저 호기롭게 도전을 시작한 것은 아닌지 불안하기도 했지만, 지금에 와서 생각해 보면 내가 만든 프로젝트를 책임진다는 것이 무엇인지를 조금이나마 배울 수 있는 시간이었던 것 같습니다.

계획대로 흘러가지 않아 불안할 때마다 칸반에 정리해놓은 것을 토대로 일정을 조율하며 너무 크게 흔들리지 않기 위해 마음을 다잡곤 했습니다. 실제로 개발하는 것만큼이나 아이디어 기획과 칸반 작성과 같은 일정 정리가 얼마나 중요한 일인지도 다시 한번 깊이 깨달았던 시간이었습니다.

아쉬운 부분이 없다면 거짓말이고 볼 때마다 부족한 부분과 새롭게 수정하고 싶은 부분들이 눈에 띄지만, 부족한 실력으로나마 최선을 다해 노력한 결과물이기에 이번 프로젝트 기간 동안 느꼈던 스스로의 부족한 점, 이를테면 기술적 또는 정신적인 면에서 보완해야 할 부분들을 잊지 않고 정진해서 다음 프로젝트 때는 한 뼘 더 성장해 있는 개발자가 되어야겠다고 다짐했습니다.
